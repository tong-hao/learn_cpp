/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "protocol/gen-cpp2/calc_types.h"
#include "protocol/gen-cpp2/calc_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "protocol/gen-cpp2/calc_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::fbthrift::calc::cpp2::AddRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "num1") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "num2") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I32;
  }
}
void TccStructTraits<::fbthrift::calc::cpp2::AddResponse>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "code") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "msg") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "ret") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace fbthrift { namespace calc { namespace cpp2 {

AddRequest::AddRequest(apache::thrift::FragileConstructor,  ::fbthrift::calc::cpp2::MyInteger num1__arg,  ::fbthrift::calc::cpp2::MyInteger num2__arg) :
    num1(std::move(num1__arg)),
    num2(std::move(num2__arg)) {
  __isset.num1 = true;
  __isset.num2 = true;
}

void AddRequest::__clear() {
  // clear all fields
  num1 = 0;
  num2 = 0;
  __isset = {};
}

bool AddRequest::operator==(const AddRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.num1 == rhs.num1)) {
    return false;
  }
  if (!(lhs.num2 == rhs.num2)) {
    return false;
  }
  return true;
}

bool AddRequest::operator<(const AddRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.num1 == rhs.num1)) {
    return lhs.num1 < rhs.num1;
  }
  if (!(lhs.num2 == rhs.num2)) {
    return lhs.num2 < rhs.num2;
  }
  return false;
}


void swap(AddRequest& a, AddRequest& b) {
  using ::std::swap;
  swap(a.num1, b.num1);
  swap(a.num2, b.num2);
  swap(a.__isset, b.__isset);
}

template void AddRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // fbthrift::calc::cpp2
namespace fbthrift { namespace calc { namespace cpp2 {

AddResponse::AddResponse(apache::thrift::FragileConstructor,  ::fbthrift::calc::cpp2::Code code__arg,  ::fbthrift::calc::cpp2::Message msg__arg,  ::fbthrift::calc::cpp2::MyInteger ret__arg) :
    code(std::move(code__arg)),
    msg(std::move(msg__arg)),
    ret(std::move(ret__arg)) {
  __isset.code = true;
  __isset.msg = true;
  __isset.ret = true;
}

void AddResponse::__clear() {
  // clear all fields
  code = 0;
  msg = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  ret = 0;
  __isset = {};
}

bool AddResponse::operator==(const AddResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return false;
  }
  if (!(lhs.msg == rhs.msg)) {
    return false;
  }
  if (!(lhs.ret == rhs.ret)) {
    return false;
  }
  return true;
}

bool AddResponse::operator<(const AddResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.code == rhs.code)) {
    return lhs.code < rhs.code;
  }
  if (!(lhs.msg == rhs.msg)) {
    return lhs.msg < rhs.msg;
  }
  if (!(lhs.ret == rhs.ret)) {
    return lhs.ret < rhs.ret;
  }
  return false;
}


void swap(AddResponse& a, AddResponse& b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.msg, b.msg);
  swap(a.ret, b.ret);
  swap(a.__isset, b.__isset);
}

template void AddResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AddResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AddResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AddResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AddResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AddResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AddResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AddResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // fbthrift::calc::cpp2
