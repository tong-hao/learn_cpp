#include <iostream>
#include <limits>
#include <string>
#include <vector>

#include "myhead.h"

class BitVector {
private:
	BitVector() = default;
	~BitVector() = default;
	BitVector(const BitVector& bitVector);
	const BitVector operator=(const BitVector& bitVector);

public:
	static void CreateFilter(const std::string* keys, int n, std::string* dst) {
		auto bits_per_key = 10;
		// Sanitize bits_per_key
		if (bits_per_key < 1.0) {
			bits_per_key = 1.0;
		} else if (!(bits_per_key < 100.0)) {  // including NaN
			bits_per_key = 100.0;
		}

		// Includes a nudge toward rounding up, to ensure on all platforms
		// that doubles specified with three decimal digits after the decimal
		// point are interpreted accurately.
		auto millibits_per_key_ =
		    static_cast<int>(bits_per_key * 1000.0 + 0.500001);

		// For now configure Ribbon filter to match Bloom FP rate and save
		// memory. (Ribbon bits per key will be ~30% less than Bloom bits per
		// key for same FP rate.) desired_one_in_fp_rate_ =
		//     1.0 / BloomMath::CacheLocalFpRate(
		//               bits_per_key,
		//               LegacyNoLocalityBloomImpl::ChooseNumProbes(millibits_per_key_),
		//               /*cache_line_bits*/ 512);

		// For better or worse, this is a rounding up of a nudged rounding up,
		// e.g. 7.4999999999999 will round up to 8, but that provides more
		// predictability against small arithmetic errors in floating point.
		auto whole_bits_per_key_ = (millibits_per_key_ + 500) / 1000;
		// Compute bloom filter size (in both bits and bytes)
		uint32_t bits = static_cast<uint32_t>(n * whole_bits_per_key_);

		// For small n, we can see a very high false positive rate.  Fix it
		// by enforcing a minimum bloom filter length.
		if (bits < 64)
			bits = 64;

		uint32_t bytes = (bits + 7) / 8;
		bits = bytes * 8;

		int num_probes = ChooseNumProbes(whole_bits_per_key_);

		const size_t init_size = dst->size();
		dst->resize(init_size + bytes, 0);
		dst->push_back(static_cast<char>(num_probes));  // Remember # of probes
		char* array = &(*dst)[init_size];
		for (int i = 0; i < n; i++) {
			AddHash(BloomHash(keys[i]), bits, num_probes, array);
		}
	}

	static bool KeyMayMatch(const std::string& key,
	                        const std::string& bloom_filter) {
		const size_t len = bloom_filter.size();
		if (len < 2 || len > 0xffffffffU) {
			return false;
		}

		const char* array = bloom_filter.data();
		const uint32_t bits = static_cast<uint32_t>(len - 1) * 8;

		// Use the encoded k so that we can read filters generated by
		// bloom filters created using different parameters.
		const int k = static_cast<uint8_t>(array[len - 1]);
		if (k > 30) {
			// Reserved for potentially new encodings for short bloom filters.
			// Consider it a match.
			return true;
		}
		// NB: using stored k not num_probes for whole_bits_per_key_
		return HashMayMatch(BloomHash(key), bits, k, array);
	}

private:
	static inline uint32_t DecodeFixed32(const char* ptr) {
		// Load the raw bytes
		uint32_t result;
		memcpy(&result, ptr,
		       sizeof(result));  // gcc optimizes this to a plain load
		return result;
	}

	static uint32_t Hash(const char* data, size_t n, uint32_t seed) {
		// MurmurHash1 - fast but mediocre quality
		// https://github.com/aappleby/smhasher/wiki/MurmurHash1
		//
		const uint32_t m = 0xc6a4a793;
		const uint32_t r = 24;
		const char* limit = data + n;
		uint32_t h = static_cast<uint32_t>(seed ^ (n * m));

		// Pick up four bytes at a time
		while (data + 4 <= limit) {
			uint32_t w = DecodeFixed32(data);
			data += 4;
			h += w;
			h *= m;
			h ^= (h >> 16);
		}

		// Pick up remaining bytes
		switch (limit - data) {
			// Note: The original hash implementation used data[i] << shift,
			// which promotes the char to int and then performs the shift. If
			// the char is negative, the shift is undefined behavior in C++. The
			// hash algorithm is part of the format definition, so we cannot
			// change it; to obtain the same behavior in a legal way we just
			// cast to uint32_t, which will do sign-extension. To guarantee
			// compatibility with architectures where chars are unsigned we
			// first cast the char to int8_t.
			case 3:
				h += static_cast<uint32_t>(static_cast<int8_t>(data[2])) << 16;
				[[fallthrough]];
			case 2:
				h += static_cast<uint32_t>(static_cast<int8_t>(data[1])) << 8;
				[[fallthrough]];
			case 1:
				h += static_cast<uint32_t>(static_cast<int8_t>(data[0]));
				h *= m;
				h ^= (h >> r);
				break;
		}
		return h;
	}

	static inline uint32_t BloomHash(const std::string& key) {
		return Hash(key.data(), key.size(), 0xbc9f1d34);
	}

	// A legacy Bloom filter implementation with no locality of probes (slow).
	// It uses double hashing to generate a sequence of hash values.
	// Asymptotic analysis is in [Kirsch,Mitzenmacher 2006], but known to have
	// subtle accuracy flaws for practical sizes [Dillinger,Manolios 2004].
	//
	// DO NOT REUSE
	//

	static inline int ChooseNumProbes(int bits_per_key) {
		// We intentionally round down to reduce probing cost a little bit
		int num_probes =
		    static_cast<int>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
		if (num_probes < 1)
			num_probes = 1;
		if (num_probes > 30)
			num_probes = 30;
		return num_probes;
	}

	static inline void AddHash(uint32_t h, uint32_t total_bits, int num_probes,
	                           char* data) {
		const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
		for (int i = 0; i < num_probes; i++) {
			const uint32_t bitpos = h % total_bits;
			data[bitpos / 8] |= (1 << (bitpos % 8));
			h += delta;
		}
	}

	static inline bool HashMayMatch(uint32_t h, uint32_t total_bits,
	                                int num_probes, const char* data) {
		const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
		for (int i = 0; i < num_probes; i++) {
			const uint32_t bitpos = h % total_bits;
			if ((data[bitpos / 8] & (1 << (bitpos % 8))) == 0) {
				return false;
			}
			h += delta;
		}
		return true;
	}
};

int main(int argc, char const* argv[]) {
	std::string dst;

	std::vector<std::string> keys{"a", "b", "c"};

	BitVector::CreateFilter(&keys[0], keys.size(), &dst);
	std::cout << dst << std::endl;

	for (auto k : keys) {
		std::cout << k << ", " << BitVector::KeyMayMatch(k, dst) << std::endl;
	}
	std::cout << "d"
	          << ", " << BitVector::KeyMayMatch("d", dst) << std::endl;

	return 1;
}

// link: --std=c++11
